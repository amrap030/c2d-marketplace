import "hashes/sha256/1024bitPadded.code" as sha256_1024;
import "hashes/sha256/512bitPadded.code" as sha256_512;
import "hashes/sha256/256bitPadded.code" as sha256_256;
import "signatures/verifyEddsa.code" as verifyEddsa;
import "ecc/babyjubjubParams.code" as context;
import "utils/pack/u32/nonStrictUnpack256.code" as unpack;
import "utils/pack/u32/pack256.code" as pack256;
import "utils/casts/u32_to_field.code" as u32_to_field;
import "utils/casts/field_to_u32.code" as field_to_u32;
from "ecc/babyjubjubParams" import BabyJubJubParams;

const field DEPTH = 32;

def main(private u32[32] mut values) -> (bool, bool, u32) {
    // // verify signature
    // BabyJubJubParams context = context();
    // bool isVerified = verifyEddsa(R, S, A, M0, M1, context);
    // assert(isVerified);

    // // calculate hash of input values from dataset
    // u32[8] hash = sha256_1024(values[0..8],values[8..16],values[16..24],values[24..32]);
    
    // // check integrity of input values
    // bool isHashMatching = hash == M0 && hash == M1;
    // assert(isHashMatching);

    // computation of sum
    field mut sum = 0;
    for u32 i in 0..32 {
        sum = sum + u32_to_field(values[i]);
    }

    u32 remainder = field_to_u32(123456789123456789);
    // u32 mean = (field_to_u32(123456789123456789) - remainder) / 32;

    // field mut tmp = 0;
    // for u32 i in 0..32 {
    //     tmp = (tmp + (u32_to_field(values[i]) - mean))**2;
    // }

    // u32 test = field_to_u32(mean);

    // // create merkle tree
    // u32[8] h_computation = sha256_256(unpack(median));
    // u32[8] h_nonce = sha256_256(unpack(nonce));

    // field result = pack256(sha256_512(h_computation, h_nonce));

    return (true, true, remainder);
}